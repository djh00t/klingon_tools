###
### klingon_tools Build & Push Script
###
### This script is used to build and push the klingon_tools package to PyPI and TestPyPI.
### It is intended to be run as a GitHub Action. The high level workflow is as follows:
###
###   1. Increment the version number in the VERSION file. Only the 3rd digit (patch) should
###      be incremented. The 1st (major) and 2nd (minor) digits should only be incremented
###      when a backwards incompatible change is made.
###   2. Build the package and run tests. If the tests fail, the script will exit.
###   3. Push the package to TestPyPI and run tests. If the tests fail, the script will exit.
###   4. Push the package to PyPI and run tests. If the tests fail, the script will exit.
###   5. If the tests pass, push the updated VERSION file back to the repository.
###
### The script uses the Makefile to perform the build and test steps. The Makefile is also
### used to increment the version number in the VERSION file.
###

name: CI

# Controls when the action will run. 
on:
  # Triggers the workflow on push or pull request events but only for the main
  # branch and not for VERSION file changes
  push:
    branches: [ main ]
    paths-ignore: [ VERSION ]
  pull_request:
    branches: [ main ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow makes sure that new releases have a higher version number
  # than the previous release in pypi and test-pypi
  check-pypi-version:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Set git user and email
      - name: Set git user and email
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'david@hooton.org'

      # Get APP_NAME
      - name: Get APP_NAME
        run: |
          echo "APP_NAME:               ${{ vars.APP_NAME }}"

      # Get PyPI Test Version Number
      - name: Get PyPI Test Version Number
        run: |
          export PYPI_TEST_VERSION=$(curl -s https://test.pypi.org/pypi/${{ vars.APP_NAME }}/json | jq -r '.info.version')
          if [[ ! $PYPI_TEST_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            PYPI_TEST_VERSION="0.0.0"
          fi
          echo "PYPI_TEST_VERSION=$PYPI_TEST_VERSION" >> $GITHUB_ENV
          echo "PYPI_TEST_VERSION:            $PYPI_TEST_VERSION"
      
      # Get PyPI Production Version Number
      - name: Get PyPI Production Version Number
        run: |
          export PYPI_PRODUCTION_VERSION=$(curl -s https://pypi.org/pypi/${{ vars.APP_NAME }}/json | jq -r '.info.version')
          if [[ ! $PYPI_PRODUCTION_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            PYPI_PRODUCTION_VERSION="0.0.0"
          fi
          echo "PYPI_PRODUCTION_VERSION=$PYPI_PRODUCTION_VERSION" >> $GITHUB_ENV
          echo "PYPI_PRODUCTION_VERSION: $PYPI_PRODUCTION_VERSION"

      # Get version number in VERSION file
      - name: Get version number in VERSION file
        run: |
          export VERSION=$(cat VERSION)
          echo "CURRENT VERSION:                $VERSION"
          echo "CURRENT_VERSION=$VERSION" >> $GITHUB_ENV
      
      # Find highest pypi version number
      - name: Find highest pypi version number
        run: |
          export HIGHEST_VERSION=$(echo -e "$VERSION\n$PYPI_TEST_VERSION\n$PYPI_PRODUCTION_VERSION" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1)
          echo "HIGHEST_VERSION:                $HIGHEST_VERSION"
          echo "HIGHEST_VERSION=$HIGHEST_VERSION" >> $GITHUB_ENV
      
      # Determine the highest version number and increment it by 0.0.1
      - name: Determine and increment version number
        run: |
          # Fetch the highest version number from PyPI, TestPyPI, VERSION file, and setup.py
          export VERSION=$(cat VERSION)
          export SETUP_VERSION=$(grep "version=" setup.py | awk -F'"' '{print $2}')
          export HIGHEST_VERSION=$(echo -e "$VERSION\n$PYPI_TEST_VERSION\n$PYPI_PRODUCTION_VERSION\n$SETUP_VERSION" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1)
          export NEW_VERSION=$(echo $HIGHEST_VERSION | awk -F. '{$NF = $NF + 1;} 1' | sed 's/ /./g')
          echo "NEW VERSION:                    $NEW_VERSION"
          echo "VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo $NEW_VERSION > VERSION
          # Update version number in setup.py
          sed -i "s/version=\"[0-9]*\.[0-9]*\.[0-9]*\"/version=\"$NEW_VERSION\"/" setup.py
          # Confirm VERSION and setup.py are in sync
          SETUP_VERSION=$(grep "version=" setup.py | awk -F'"' '{print $2}')
          if [ "$NEW_VERSION" != "$SETUP_VERSION" ]; then
            echo "Error: VERSION and setup.py are not in sync"
            exit 1
          fi

      # Push changes and create a new tag
      - name: Push changes and create tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git add VERSION setup.py
          git commit -m "Update version number to $NEW_VERSION"
          git tag -a v$NEW_VERSION -m "Version $NEW_VERSION"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }} HEAD:main --tags
          sleep 5

  # build-test workflow
  build-test:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    needs: check-pypi-version

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Setup python environment
      - name: Set up Python 3.9
        uses: actions/setup-python@v4
        with:
          python-version: 3.x

      # Set git user and email
      - name: Set git user and email
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'david@hooton.org'
      
      # Get APP_NAME
      - name: Get APP_NAME
        run: |
          echo "APP_NAME:               ${{ vars.APP_NAME }}"

      # Echo the new version number
      - name: Echo the version number
        run: |
          git pull || true
          export VERSION=$(cat VERSION)
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "VERSION:                        $VERSION"


      # Compile requirements if requirements.in is not empty
      - name: Compile requirements
        run: |
          if [ -s requirements.in ]; then
            pip install pip-tools
            pip-compile requirements.in
          else
            echo "requirements.in is empty, skipping pip-compile"
          fi

      # Install dependencies if requirements.txt exists
      - name: Install dependencies
        run: |
          if [ -f requirements.txt ]; then
            python -m pip install --upgrade pip
            pip install -r requirements.txt
          else
            echo "requirements.txt is missing, skipping installation"
          fi
      
      # Builds the package and runs tests
      - name: Build and test
        run: |
          pip install .
          make sdist
          make wheel
          make test

      # If tests pass, push the package to TestPyPI
      - name: Push to TestPyPI
        run: |
          make upload-test TEST_PYPI_USER_AGENT=${{ secrets.TEST_PYPI_USER_AGENT }}

      # Pull the package from TestPyPI and run tests
#      - name: Pull from TestPyPI and test
#        run: |
#          pip install --index-url https://test.pypi.org/simple/ klingon-file-manager
#          python -m unittest discover

  build-production:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    needs: build-test

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Setup python environment
      - name: Set up Python 3.9
        uses: actions/setup-python@v4
        with:
          python-version: 3.x
          
      # Install dependencies
      - name: Install dependencies
        run: |
          make check-packages

      # Set git user and email
      - name: Set git user and email
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'david@hooton.org'

      # Get APP_NAME from Variables
      - name: Get APP_NAME from Variables
        run: |
          echo "APP_NAME:               ${{ vars.APP_NAME }}"

      # Echo the new version number
      - name: Echo the version number
        run: |
          git pull || true
          export VERSION=$(cat VERSION)
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "VERSION:                        $VERSION"

      # Compile requirements if requirements.in is not empty
      - name: Compile requirements
        run: |
          if [ -s requirements.in ]; then
            pip install pip-tools
            pip-compile requirements.in
          else
            echo "requirements.in is empty, skipping pip-compile"
          fi

      # Install dependencies if requirements.txt exists
      - name: Install dependencies
        run: |
          if [ -f requirements.txt ]; then
            python -m pip install --upgrade pip
            pip install -r requirements.txt
          else
            echo "requirements.txt is missing, skipping installation"
          fi

      # Builds the package and runs tests
      - name: Build and test
        run: |
          pip install .
          make sdist
          make wheel
          make test

      # If tests pass, pushes the package to PyPI and runs tests
      - name: Push to PyPI
        run: |
          make upload PYPI_USER_AGENT=${{ secrets.PYPI_USER_AGENT }}

#       # If uploads are successful, and the VERSION file has changed, tag the
#       # codebase and push the code and tags to the repository
#       - name: Tag and push
#         run: |
#           git pull || true
#           git tag -a v${VERSION} -m "Version v${VERSION}"
#           git push origin v${VERSION}
#           git push || true
#           sleep 5
  create-release:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    needs: build-production

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Set git user and email
      - name: Set git user and email
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'david@hooton.org'

      # Get APP_NAME from Variables
      - name: Get APP_NAME from Variables
        run: |
          echo "APP_NAME:               ${{ vars.APP_NAME }}"

      # Echo the new version number
      - name: Echo the version number
        run: |
          git pull || true
          export VERSION=$(cat VERSION)
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "VERSION:                        $VERSION"

      - name: "Complex Configuration"
        id: build_changelog
        # if: startsWith(github.ref, 'refs/tags/')
        uses: mikepenz/release-changelog-builder-action@{latest-release}
        with:
          configuration: "release_configuration_complex.json"
          owner: "djh00t"
          repo: "klingon_tools"
          ignorePreReleases: "false"
          token: ${{ secrets.GITHUB_TOKEN  }}

      - name: Create Release
        uses: mikepenz/action-gh-release@v0.4.0
        with:
          body: ${{steps.github_release.outputs.changelog}}
          generate_release_notes: true
          tag_name: v$VERSION
