#!/usr/bin/env python
# -*- coding: utf-8 -*-
import logging
import os
import subprocess
import sys
import argparse
import atexit
import signal
import textwrap
from git import Repo, InvalidGitRepositoryError, NoSuchPathError
from openai import OpenAI
from klingon_tools import LogTools

# Initialize the logger
log_tools = LogTools()
logger = log_tools.log_message

# Set the global log message style
log_tools.set_default_style("default")

# Initialize the OpenAI API client
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Configuration & Variables
LOOP_MAX_PRE_COMMIT = 5


class GitHandler:
    """
    GitHandler class to manage interactions with a Git repository.
    """

    def __init__(self, repo_path):
        """
        Initialize GitHandler with the path to the Git repository.

        Args:
            repo_path (str): Path to the Git repository.
        """
        self.repo_path = repo_path
        self.repo = None
        self.deleted_files = []
        self.untracked_files = []
        self.modified_files = []
        self.staged_files = []
        self.committed_not_pushed = []

    def initialize_repo(self):
        """
        Initialize the Git repository object.
        """
        try:
            self.repo = Repo(self.repo_path, search_parent_directories=True)
        except (InvalidGitRepositoryError, NoSuchPathError) as e:
            logger.error(f"Error: {e}")
            sys.exit(1)

    def get_status(self):
        """
        Get the current status of the Git repository.
        """
        if not self.repo:
            logger.error("Repository not initialized.")
            return

        current_branch = self.repo.active_branch
        self.deleted_files = [
            item.a_path
            for item in self.repo.index.diff(None)
            if item.change_type == "D"
        ]
        self.untracked_files = self.repo.untracked_files
        self.modified_files = [
            item.a_path
            for item in self.repo.index.diff(None)
            if item.change_type == "M"
        ]
        self.staged_files = [item.a_path for item in self.repo.index.diff("HEAD")]
        self.committed_not_pushed = []

        try:
            for item in self.repo.head.commit.diff(f"origin/{current_branch}"):
                if hasattr(item, "a_blob") and hasattr(item, "b_blob"):
                    self.committed_not_pushed.append(item.a_path)
        except ValueError as e:
            logger.error(f"Error processing diff-tree output: {e}")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")

    def commit_deleted_files(self):
        """
        Commit deleted files in the repository.
        """
        if self.deleted_files:
            all_deleted_files = list(
                set(
                    self.deleted_files
                    + [
                        item.a_path
                        for item in self.repo.index.diff("HEAD")
                        if item.change_type == "D"
                    ]
                )
            )

            logger.info(f"There are {len(all_deleted_files)} deleted files.")
            logger.debug(f"Deleted files: {all_deleted_files}")

            for file in all_deleted_files:
                self.repo.index.remove([file], working_tree=True)

            commit_message = "Committing deleted files"
            self.repo.index.commit(commit_message)

            logger.info(
                f"Committed {len(all_deleted_files)} deleted files with message: '{commit_message}'."
            )

    def unstage_files(self):
        """
        Unstage all staged files in the repository.
        """
        for file in self.staged_files:
            try:
                self.repo.git.reset(file)
                logger.info("Un-staging file", status=file)
            except git.exc.GitCommandError as e:
                logger.error("Error un-staging file", status=file)
                logger.exception(f"{e}")

    def stage_diff(self, file_name):
        """
        Stage changes for a specific file in the repository.

        Args:
            file_name (str): Name of the file to stage.

        Returns:
            str: Commit message generated for the staged changes.
        """
        self.repo.index.add([file_name])
        staged_files = self.repo.git.diff("--cached", "--name-only").splitlines()

        logger.debug("Staged files", status=staged_files)

        if file_name in staged_files:
            logger.info("Staging file", status="‚úÖ")
        else:
            logger.error("Failed to stage file", status="‚ùå")
            sys.exit(1)

        diff = self.repo.git.diff("HEAD", file_name)
        commit_message = self.generate_commit_message(diff)

        return commit_message

    def pre_commit(self, file_name, commit_message):
        """
        Run pre-commit hooks for the staged file and commit if successful.

        Args:
            file_name (str): Name of the staged file.
            commit_message (str): Commit message for the file changes.
        """
        attempt = 0

        while attempt < LOOP_MAX_PRE_COMMIT:
            env = os.environ.copy()
            env["PYTHONUNBUFFERED"] = "1"

            process = subprocess.Popen(
                ["pre-commit", "run", "--files", file_name],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                env=env,
            )

            stdout, stderr = process.communicate()

            if "files were modified by this hook" in stdout:
                logger.info("File modified by pre-commit, restaging", status="üîÑ")
                self.repo.index.add([file_name])
                attempt += 1
                if attempt == LOOP_MAX_PRE_COMMIT:
                    logger.error(
                        f"Pre-commit hooks failed for {file_name} after {LOOP_MAX_PRE_COMMIT} attempts. Exiting script."
                    )
                    sys.exit(1)
            elif process.returncode == 0:
                logger.info("Pre-commit completed", status="‚úÖ")
                self.commit_file(file_name, commit_message)
                self.push_changes()
                break

    def commit_file(self, file_name, commit_message):
        """
        Commit a specific file with a given commit message.

        Args:
            file_name (str): Name of the file to commit.
            commit_message (str): Commit message for the file changes.
        """
        self.repo.index.add([file_name])

        try:
            self.repo.index.commit(commit_message)
            logger.info("File committed", status="‚úÖ")
        except Exception as e:
            logger.error("Failed to commit file", status="‚ùå", reason=str(e))

    def push_changes(self):
        """
        Push committed changes to the remote Git repository.
        """
        try:
            self.repo.remotes.origin.push()
            logger.info("Pushed changes to remote repository", status="‚úÖ")
        except Exception as e:
            logger.error(
                "Failed to push changes to remote repository",
                status="‚ùå",
                reason=str(e),
            )

    def generate_commit_message(self, diff):
        """
        Generate a commit message based on the diff of the staged changes.

        Args:
            diff (str): Git diff of the staged changes.

        Returns:
            str: Generated commit message.
        """
        role_system_content = """
        Generate a commit message based solely on the staged diffs provided, ensuring accuracy and relevance to the actual changes.
        """

        role_user_content_template = """
        Generate a git commit message based on these diffs (git --no-pager diff --patch-with-stat):
        \"{diff}\"
        """

        role_user_content = role_user_content_template.format(diff=diff)

        response = client.chat.completions.create(
            messages=[
                {"role": "system", "content": role_system_content},
                {"role": "user", "content": role_user_content},
            ],
            model="gpt-3.5-turbo",
        )

        commit_message = response.choices[0].message.content.strip()
        commit_message = "\n".join(
            [
                (
                    " " + line
                    if len(line) <= 78
                    else "\n".join(
                        " " + wrapped_line for wrapped_line in textwrap.wrap(line, 78)
                    )
                )
                for line in commit_message.split("\n")
            ]
        )

        logger.info(80 * "-", status="")
        logger.info(f"Generated commit message:\n\n{commit_message}\n")
        logger.info(80 * "-", status="")

        return commit_message


def initialize_logging(debug=False):
    """
    Initialize logging configuration.

    Args:
        debug (bool): Enable debug mode if True.
    """
    if debug:
        logger.info("Debug mode is enabled.", status="üêõ")
        log_tools.configure_logging()

    httpx_logger = logging.getLogger("httpx")
    httpx_logger.setLevel(logging.WARNING)


def check_software_requirements():
    """
    Check if pre-commit is installed; install if not.
    """
    try:
        subprocess.run(
            ["pre-commit", "--version"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        logger.info(80 * "=", status="")
        logger.info("Checking for software requirements", status="‚úÖ")
    except subprocess.CalledProcessError:
        logger.warning("pre-commit is not installed.", status="Installing")
        subprocess.run(
            [sys.executable, "-m", "pip", "install", "pre-commit"], check=True
        )
        subprocess.run(["pre-commit", "install"], check=True)
        logger.info("pre-commit has been installed and hooks are set up.", status="‚úÖ")


def setup_signal_handlers(repo_path):
    """
    Set up signal handlers to clean up on exit.

    Args:
        repo_path (str): Path to the Git repository.
    """

    def cleanup_lock_file(repo_path):
        lock_file_path = os.path.join(repo_path, ".git", "index.lock")
        if os.path.exists(lock_file_path):
            os.remove(lock_file_path)
            logger.info("Removed Git index lock file.", status="‚úÖ")

    atexit.register(cleanup_lock_file, repo_path)
    signal.signal(signal.SIGINT, lambda signal, frame: sys.exit(0))
    signal.signal(signal.SIGTERM, lambda signal, frame: sys.exit(0))


def setup_arg_parser():
    """
    Set up argument parser for the script.
    """
    parser = argparse.ArgumentParser(
        description="Git Automation Script",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "-f",
        "--file-name",
        metavar="FILE",
        type=str,
        help="Specify a file to stage and commit.",
    )
    parser.add_argument(
        "--oneshot", action="store_true", help="Exit after performing one action."
    )
    parser.add_argument("--debug", action="store_true", help="Enable debug mode.")
    return parser


def main():
    """
    Main function to orchestrate the Git automation tasks.
    """
    # Set up signal handlers
    logger.debug("Setting up signal handlers.")
    setup_signal_handlers(repo_path=os.getcwd())

    # Parse command-line arguments
    logger.debug("Setting up argument parser.")
    parser = setup_arg_parser()
    logger.debug("Parsing command-line arguments.")
    args = parser.parse_args()

    # Initialize logging
    logger.debug("Initializing logging.")
    initialize_logging(debug=False)

    # Check software requirements
    logger.debug("Checking software requirements.")
    check_software_requirements()

    # Initialize GitHandler
    logger.debug("Initializing GitHandler.")
    repo_handler = GitHandler(repo_path=os.getcwd())

    # Initialize the Git repository
    logger.debug("Initializing Git repository.")
    repo_handler.initialize_repo()

    # Get the current status of the repository
    logger.debug("Getting repository status.")
    repo_handler.get_status()

    if args.file_name:
        logger.debug(f"Staging diff for {args.file_name}")
        commit_message = repo_handler.stage_diff(args.file_name)

        logger.debug(f"Pre-commit for {args.file_name}")
        repo_handler.pre_commit(args.file_name, commit_message)

    if args.oneshot:
        logger.debug("--oneshot selected, exiting script.")
        sys.exit(0)


if __name__ == "__main__":
    main()
